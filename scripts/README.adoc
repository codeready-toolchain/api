= Scripts
This directory contains a set of bash scripts that helps us with maintaining and managing OLM catalog files. The following part describes the purpose and functionality of all the script files.


== olm-setup.sh
The `olm-setup.sh` script is a collection of common functions used by other scripts. Executing this script on its own wouldn't do anything.


[#generate-deploy-hack]
== generate-deploy-hack.sh
The `generate-deploy-hack.sh` script generates the `deploy_csv.yaml` file containing two objects:

* `ConfigMap` containing all detected CSVs, CRDs and package file.
* `CatalogSource` that adds the operator into the OperatorHub and uses the `ConfigMap` as a source of operator bundle.

This `deploy_csv.yaml` file can be used for easy deployment of the operator in dev cluster as well as for testing purposes.

NOTE: This script requires multiple parameters - see help for more information.


== olm-catalog-generate.sh
The `olm-catalog-generate.sh` script (re)generates OLM catalog files in their respective operator repositories/directories.
It generates:

* The operator bundle that is used as the base template for all next releases.
* Some "hack" files, including:
** `deploy_csv.yaml` that helps in deploying the current version of the operator bundle to the cluster. It's the same file as is generated using <<generate-deploy-hack,generate-deploy-hack.sh>> script.
** `install_operator.yaml` that installs the operator using `OperatorGroup` and `Subscription` resources.

Under the hood, it runs the `operator-sdk` command with specific parameters.
If the operator repository contains CRD types (i.e., contains the `pkg/apis/toolchain/v1alpha1` directory) it decides where the `operator-sdk` command will be executed.

* If the repository contains the CRD types (in case of toolchain-operator) then the command is executed inside of the operator repo.
* If the repository doesn't contain the CRD types (in case of hosted toolchain operators) then the command is executed inside of codeready-toolchain/api repo. To do that, the script:
+
1. Either copies (if the script is called locally) or clones the codeready-toolchain/api into a temp directory.
2. Copies the operator's `csv-config.yaml` file to a temp location and modifies the paths so it points to the correct files and directories.
3. Copies the whole operator package directory into the api repo.
4. Runs `operator-sdk` command by feeding it with the temporal `csv-config.yaml` file.
5. Copies the operator package directory back to the operator repo.

NOTE: The `olm-catalog-generate.sh` requires a single parameter `--project-root`, and optionally the `--allnamespaces` param. It relies on `olm-setup.sh`.


== enrich-by-envs-from-yaml.sh
The `enrich-by-envs-from-yaml.sh` script takes two parameters:

1. path to CSV the deployment variables should be added to
2. path to an environment configuration file

If the provided environment configuration file exists then it transforms it into a list of key-value pairs.
The keys are generated by joining all YAML keys that are on the path to the value.
For example, with the following environment configuration:
```yaml
registration-service:
  environment: 'dev'
  replicas: 2
  auth-client:
    library-url: 'https://sso..../keycloak.js'
    public-keys-url: 'https://sso..../certs'
```
the resulting list of key-value pairs would be:
``` yaml
REGISTRATION_SERVICE_ENV : 'dev'
REGISTRATION_SERVICE_REPLICAS : 2
REGISTRATION_SERVICE_AUTH_CLIENT_LIBRARY_URL : 'https://sso..../keycloak.js'
REGISTRATION_SERVICE_AUTH_CLIENT_PUBLIC_KEYS_URL : 'https://sso..../certs'
```
Once the key-value pairs have been generated, they are included in the CSV as additional environment parameters of the operator deployment.
The modified CSV is printed on the standard output.


== generate-cd-release-manifests.sh
The `generate-cd-release-manifests.sh` regenerates operator bundles manifests for the latest commit in master.
The simplified flow of the script is the following:

1. It calculates the version of the new CSV and of the previous one as well.
2. It runs the `operator-sdk` command to regenerate the operator bundle manifests using the versions for the latest commit in master.
3. It replaces the variables and parameters in the newly regenerated CSV.
4. It executes the `enrich-by-envs-from-yaml.sh` script to parse the `<operator-repo>/deploy/env/prod.yaml` file (if it exists) and to add additional deployment variables into the CSV.

NOTE: The `generate-cd-release-manifests.sh` requires a single parameter `--project-root`, and optionally `--operator-name`, `--embedded-repo` as well as `--quay-namespace`. It relies on `olm-setup.sh`.


== push-manifests-as-app.sh
The `push-manifests-as-app.sh` takes the current operator bundle manifests in the `deploy/olm-catalog/<operator-name>/` directory and pushes them as an application to the "nightly" channel to https://quay.io[].
The simplified flow of the script is the following:

1. It calculates the version of the new CSV and of the previous one as well.
2. Copies the manifests to a new versioned directory `deploy/olm-catalog/<operator-name>/<manifests-version>/`
3. Sets the channel to "nightly" in the package yaml file.
4. Retrieves the Quay auth token. If the `QUAY_AUTH_TOKEN` variable is not provided then it uses the token found in the `~/.docker/config.json` file.
5. Using the `operator-courier` binary it pushes the new operator bundle as a package (application) to https://quay.io[].

NOTE: The `push-manifests-as-app.sh` requires a single parameter `--project-root`, and optionally `--operator-name`, `--embedded-repo`, `--quay-namespace` as well as `--channel` in case you want to use different channel than "nightly". It relies on `olm-setup.sh`.


== push-bundle-and-index-image.sh
The `push-bundle-and-index-image.sh` takes the current operator bundle manifests in the `deploy/olm-catalog/<operator-name>/` directory and using the files it generates bundle image (uses "staging" channel), adds it to an index image and pushes them to a repository in https://quay.io[].
The simplified flow of the script is the following:

1. Reads the new version in CSV, parses it and checks if it contains 5 parts which means that when the CSV was being generated then either embedded or main repo was specified (eg. host-operator / registration-service)
2. If the version contains 5 parts then it checks if the "replaces" version corresponds to what is in the index image:
.. Reads the "replaces" version in the CSV
.. Calls `opm index export` command for the given index and operator name and redirects the output to a file
.. As soon as the file contains information that `opm` starts pulling bundle images, then the scripts stop the command and reads the latest version specified in the output line.
.. Compare the "replaces" version from CSV with the latest version in index and if
* they are the same, then it continues using the same "replaces" version.
* if they both have "at least something in common", then the script assumes that there was one or more commits of the same repository skipped so it uses the version from the index as the one for replacement.
* (there are more cases - see the script and the inline comments for more info)

3. Replaces the channel name to "staging" in both bundle.Dockerfile and metadata/annotations.yaml.
4. Builds a container for a bundle image.
5. Builds the bundle image and pushes it to quay.
6. Adds the bundle image to index image and pushes it to quay.

NOTE: The `push-bundle-and-index-image.sh` requires two parameters `--project-root` and `--index-image`, and optionally `--operator-name`, `--embedded-repo`, `--quay-namespace`, `--image-builder` as well as `--channel` in case you want to use different channel than "staging". It relies on `olm-setup.sh`.


== create-release-bundle.sh
The `create-release-bundle.sh` script creates an operator bundle (not the image, only the bundle) of a given version in `<project-root>/manifests/` directory.
The simplified flow of the script is the following:

1. Lists and sorts all existing directories in `<project-root>/manifests/`, detects the latest one (according to semver) and takes the directory name (which is the latest CSV version).
2. It runs the `operator-sdk` command to generate a new version of the operator bundle (for the "alpha" channel) using  the base template in `<operator-repo>/deploy/olm-catalog/`.
3. It replaces all the variables and parameters in the newly generated CSV.
4. It runs the `enrich-by-envs-from-yaml.sh` script to parse the `<operator-repo>/deploy/env/prod.yaml` file (if it exists) and adds the additional deployment variables into the CSV.
5. Deletes metadata/ folder and bundle.Dockerfile that is related to the new operator bundle image format.
6. It copies the operator bundle in the `<project-root>/manifests/` directory and updates the `*-package.yaml` file at the root of this directory.
7. It verifies the generated operator bundle with the help of the `operator-courier` binary.
8. It generates the deploy hack file to make testing of the bundle easier.

The `create-release-bundle.sh` script doesn't push anything to quay yet - to do that please use the `push-to-quay-manifests.sh` script described below.

NOTE: The `create-release-bundle.sh` script requires two parameters `--project-root` and `--next-version` and optionally `--operator-name`, `--embedded-repo` and `--quay-namespace`. It relies on `olm-setup.sh`.


== push-to-quay-manifest.sh
The `push-to-quay-manifest.sh` script takes the latest release manifest (according to semver) from the `<project-root>/manifests/` directory and pushes it to https://quay.io[].

NOTE: The script uses auth token taken either from `QUAY_AUTH_TOKEN` variable or from `~/.docker/config.json` file to upload the bundles.

NOTE: The script requires a single parameter `--project-root` and optionally `--operator-name`. It relies on `olm-setup.sh`.
